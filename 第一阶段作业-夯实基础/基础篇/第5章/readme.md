# 第五章学习笔记

#### 1	继承

**什么是继承**

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

**类的继承格式**

```
class 父类 {

 } 
class 子类 extends 父类 { 

}
```

**继承的优点**

当子类继承父类之后就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码）

- 子类继承父类所有的属性和方法（但不能直接访问 private 成员）
- 子类构造函数默认第一句话都会去调用父类的构造函数
- 根据信息隐藏原则：子类会继承父类所有的方法。可以直接使用。
- 子类也会继承父类的父类的所有的属性和方法（但不能直接访问 private 成员）
- 单根继承原则：每个类都只能继承一个类，Java的继承只能是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这也是 Java 继承区别于 C++ 继承的一个特性。
- 如果不写 extends,Java 类都默认继承 java.lang.Object 类。class Human extends java.lang.Object，Java 所有的类都是从 java.lang.Object 开始，构建出一个类型继承树，Object 类里面默认就有 clone, equals, finalize, getClass, hashCode, toString 等方法
- super关键字：当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字 **super**。super.父类方法名（调用父类的方法），子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类中如果定义了构造方法并且构造方法带有参数，子类也必须定义一个构造方法，且必须在构造方法的第一行用super调用父类的构造函数，必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表（如：super（参数）;调用父类中带有参数的构造器）。如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。

#### 2	抽象类和接口

- 类：属性 (0个或多个） +方法 (0个或多个）
- 一个完整(健康)的类：所有的方法都有实现(方法体)
- 类可以没有方法，但是有方法就肯定要有实现，这才是一个完整的类
- 一个完整的类才可以被实例化，被 new 出来
- 如果一个类暂时有方法未实现，需要被定义为抽象类

**抽象类（abstract）**

- 抽象类使用关键字abstract声明

- 抽象类的组成
  - 成员变量，个数不限
  - 具体方法，方法有实现，个数不限
  - 抽象方法，加abstract关键字，个数不限
- 抽象类也是类。一个类继承于抽象类，就不能继承于其他的(抽象)类
- 子类可以继承于抽象类，但是一定要实现父类们所有abstract的方法。如果不能完全实现，那么子类也必须被定义为抽象类。
- 只有实现父类(们)的所有抽象方法，才变成完整类。

**接口(interface )**

- 如果类的所有方法都没有实现，那么这个类就算是接口。
- 接口不算类，或者说是“特殊”的类。
- 类只可以继承(extends)一个类，但是可以实现(implements)多个接口，继承和实现可以同时。
- 接口可以继承(多个)接口，没有实现的方法将会叠加
- 类实现接口，就必须实现所有未实现的方法。如果没有全部实现，那么只能成为一个抽象类。
- 接口里可以定义变量，但是一般是常量

**重点归纳：**

- 抽象类和接口相同点：两者都不能被实例化，不能 new 操作
- 抽象类和接口不同点
  - 抽象类 abstract, 接口 interface
  - 抽象类可以有部分方法实现，接口所有方法不能有实现
  - 一个类只能继承(extends)一个(抽象)类，实现 (implements)多个接口
  - 接口可以继承(extends)多个接口
  - 抽象类有构造函数，接口没有构造函数
  - 抽象类可以有 main ，也可以运行，接口没有main函数
  - 抽象类方法可以有 private/protected, 接口方法都是 public



#### 3	转型、多态和契约设计

**类转型**

- 变量支持互相转化,比如

  ```
   int a = (int) 3.5;
  ```

- 类型可以相互转型，但是只限制于有继承关系的类。

  - 子类可以转换成父类，而父类不可以转为子类。
  - 子类继承父类所有的财产，子类可以变成父类(从大变小，即向上转型 )
  - 从父类直接变成子类(从小变大，即 向下转型)则不允许。

```
HUman obj1 = new Man();
Man obj2 = new Human();
```

- 父类转为子类有一种情况例外--就是这个父类本身就是从子类转化过来的。

```
Human obj1 = new Man();
Man obj2 = (man) obj1;
```

**多态**

- 类型转换，带来的作用就是多态。
- 子类继承父类的所有方法，但子类可以重新定义一个名字、参数和父类一样的方法，这种行为就是重写
- 子类的方法的优先级高于父类的。
- 子类转型为父类后，调用普通方法，依旧是子类的方法

**多态的作用**

- 以统一的接口来操纵某一类中不同的对象的动态行为
- 对象之间的解耦

**契约设计**

- 契约：规定规范了对象应该包含的行为方法
- 接口定义了方法的名称、参数和返回值，规范了派生类的行为
- 基于接口，利用转型和多态，不影响真正方法的调用，成功地将调用类和被调用类解耦 
- 类不会直接使用另外一个类，而是采用接口的形式，外部可以“空投”这个接口下的任意子类对象